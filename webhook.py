import os
import json
import time
import hmac
import hashlib
import logging
import re
import random
import threading
from typing import Dict, Iterable, Tuple
from flask import Flask, request, abort, jsonify

# === Importurile tale existente pentru trimitere mesaje/replies ===
from send_message import (
    send_instagram_message,           # DM to user_id
    reply_public_to_comment,          # public ack under comment (dacƒÉ platforma permite)

)
app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

# === ENV (exact ca √Æn Railway) ===
VERIFY_TOKEN = os.getenv("IG_VERIFY_TOKEN", "").strip()
APP_SECRET   = os.getenv("IG_APP_SECRET", "").strip()  # op»õional, pentru semnƒÉturƒÉ
MY_IG_USER_ID = os.getenv("IG_ID", "").strip()

# === Dedup DM (MID) ‚Äî 5 minute ===
SEEN_MIDS: Dict[str, float] = {}
DEDUP_TTL_SEC = 300

# === Anti-spam ofertƒÉ (o singurƒÉ replicƒÉ per user √Æntr-un interval) ===
OFFER_COOLDOWN_SEC = int(os.getenv("OFFER_COOLDOWN_SEC", "180"))  # default 3 min
LAST_OFFER_AT: Dict[str, float] = {}  # sender_id -> epoch

# === Dedup comentarii ‚Äî 1 orƒÉ ===
PROCESSED_COMMENTS: Dict[str, float] = {}
COMMENT_TTL = 3600  # 1 orƒÉ √Æn secunde

REPLY_DELAY_MIN_SEC = float(os.getenv("REPLY_DELAY_MIN_SEC", "4.0"))
REPLY_DELAY_MAX_SEC = float(os.getenv("REPLY_DELAY_MAX_SEC", "7.0"))

# === Texte ofertƒÉ ===
OFFER_TEXT_RO = (
    "Salutare üëã\n\n"
    "Avem modele pentru profesori, personalizabile cu text, care sunt la pre»õ de 650 lei\n\n"
    "Facem »ôi lucrƒÉri la comandƒÉ √Æn baza pozei, la pre»õ de 780 lei\n\n"
    "LƒÉmpile au 16 culori »ôi o telecomandƒÉ √Æn set ü•∞\n\n"
    "Primi»õi 6 luni garan»õie la toatƒÉ electronica‚ö°\n\n"
    "Pentru ce tip de lampƒÉ a»õi opta ?"
)
OFFER_TEXT_RU = (
    "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ üëã\n\n"
    "–£ –Ω–∞—Å –µ—Å—Ç—å –º–æ–¥–µ–ª–∏ –¥–ª—è —É—á–∏—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å —Ç–µ–∫—Å—Ç–æ–º, –∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–æ—è—Ç 650 –ª–µ–π\n\n"
    "–¢–∞–∫–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ–º —Ä–∞–±–æ—Ç—ã –Ω–∞ –∑–∞–∫–∞–∑ –ø–æ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, —Å—Ç–æ–∏–º–æ—Å—Ç—å ‚Äî 780 –ª–µ–π\n\n"
    "–õ–∞–º–ø—ã –∏–º–µ—é—Ç 16 —Ü–≤–µ—Ç–æ–≤ –∏ –ø—É–ª—å—Ç –≤ –∫–æ–º–ø–ª–µ–∫—Ç–µ ü•∞\n\n"
    "–í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ 6 –º–µ—Å—è—Ü–µ–≤ –≥–∞—Ä–∞–Ω—Ç–∏–∏ –Ω–∞ –≤—Å—é —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫—É‚ö°\n\n"
    "–ö–∞–∫–æ–π —Ç–∏–ø –ª–∞–º–ø—ã –≤—ã –±—ã –≤—ã–±—Ä–∞–ª–∏?"
)

# === Mesaj public scurt sub comentariu ===
ACK_PUBLIC_RO = "BunƒÉ üëã V-am rƒÉspuns √Æn privat üíå"
ACK_PUBLIC_RU = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ üëã\n–û—Ç–≤–µ—Ç–∏–ª–∏ –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è üíå"

# === Offer intent (price/catalog/models/details) ‚Äî RO + RU extins ===
CYRILLIC_RE = re.compile(r"[\u0400-\u04FF]")

# RO ‚Äî termeni legati de pret
RO_PRICE_TERMS = {
    "pret","pretul","preturi","tarif","cost","costa","cat e","cat este","cat costa",
    "cat vine","cat ajunge","care e pretul","aveti preturi","oferta","oferti","price",
}

# RO ‚Äî termeni de produs / categorie
RO_PRODUCT_TERMS = {
    "lampa","lampa","lampi","lampe","lampƒÉ","lampile","modele","model","catalog","neon",
    "pentru profesori","profesori","profesor",
}

# RO ‚Äî termeni de detalii / informatii
RO_DETAIL_TERMS = {
    "detalii","mai multe detalii","informatii","informa»õii","descriere","specificatii",
    "detalii despre","vreau detalii","doresc detalii","as dori detalii","as dori informatii",
    "doresc mai multe informatii","spune-mi mai multe","spuneti-mi mai multe","mai multe info",
}

# RO ‚Äî comparatori
RO_COMPARATORS = {
    "diferit","diferite","acelasi","acela»ôi","pentru orice","toate modelele","depinde de model",
}

# RU ‚Äî termeni legati de pret
RU_PRICE_TERMS = {
    "—Ü–µ–Ω–∞","—Ü–µ–Ω—ã","–ø—Ä–∞–π—Å","—Å—Ç–æ–∏–º–æ—Å—Ç—å","—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç","—Å–∫–æ–ª—å–∫–æ —Ü–µ–Ω–∞","—Å–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç",
    "–ø–æ —á–µ–º","–ø–æ—á–µ–º","—É–∑–Ω–∞—Ç—å —Ü–µ–Ω—É","–º–æ–∂–Ω–æ —É–∑–Ω–∞—Ç—å —Ü–µ–Ω—É","—Å–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç —Å—Ç–æ–∏—Ç—å","—Å–∫ —Å–∫–æ–ª—å–∫–æ",
}

# RU ‚Äî termeni de produs / categorie
RU_PRODUCT_TERMS = {
    "–ª–∞–º–ø–∞","–ª–∞–º–ø—ã","–º–æ–¥–µ–ª—å","–º–æ–¥–µ–ª–∏","–∫–∞—Ç–∞–ª–æ–≥","–¥–ª—è —É—á–∏—Ç–µ–ª—è","—É—á–∏—Ç–µ–ª—é","—É—á–∏—Ç–µ–ª—è–º","–Ω–µ–æ–Ω",
}

# RU ‚Äî detalii/informa»õii
RU_DETAIL_TERMS = {
    "–ø–æ–¥—Ä–æ–±–Ω–µ–µ","–¥–µ—Ç–∞–ª–∏","—Ö–æ—á—É –¥–µ—Ç–∞–ª–∏","—Ä–∞—Å—Å–∫–∞–∂–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ","–º–æ–∂–Ω–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ",
    "–±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏","—É–∑–Ω–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ","–∏–Ω—Ñ–æ","–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
}

# RU ‚Äî comparatori
RU_COMPARATORS = {
    "—Ä–∞–∑–Ω–∞—è","—Ä–∞–∑–Ω—ã–µ","–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è","–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è —Ü–µ–Ω–∞","–¥–ª—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π","–∑–∞–≤–∏—Å–∏—Ç –æ—Ç –º–æ–¥–µ–ª–∏",
}

# Expresii compuse (ancore clare)
RO_PRICE_REGEX = re.compile(
    r"(care\s+e\s+pretul|sunt\s+preturi\s+diferite|acelasi\s+pret|pret\s+pe\s+model|pret\s+pentru\s+orice\s+model)",
    re.IGNORECASE,
)
RU_PRICE_REGEX = re.compile(
    r"(—Ü–µ–Ω–∞\s+–¥–ª—è\s+–≤—Å–µ—Ö\s+–º–æ–¥–µ–ª–µ–π|—Ä–∞–∑–Ω–∞—è\s+—Ü–µ–Ω–∞|–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è\s+—Ü–µ–Ω–∞|—Ü–µ–Ω–∞\s+–∑–∞\s+–º–æ–¥–µ–ª—å|–º–æ–∂–Ω–æ\s+—É–∑–Ω–∞—Ç—å\s+—Ü–µ–Ω—É)",
    re.IGNORECASE,
)


ETA_TEXT = (
    "Lucrarea se elaboreazƒÉ timp de 3-4 zile lucrƒÉtoare\n\n"
    "Livrarea dureazƒÉ de la o zi p√¢nƒÉ la trei zile independent de metodƒÉ »ôi loca»õie\n\n"
    "A»õi avea nevoie de produs pentru o anumitƒÉ datƒÉ?\n\n"
    "Unde va trebui de livrat produsul?"
)

ETA_TEXT_RU = (
    "–ò–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ –∏–∑–¥–µ–ª–∏—è –∑–∞–Ω–∏–º–∞–µ—Ç 3-4 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è\n\n"
    "–î–æ—Å—Ç–∞–≤–∫–∞ –¥–ª–∏—Ç—Å—è –æ—Ç –æ–¥–Ω–æ–≥–æ –¥–æ —Ç—Ä—ë—Ö –¥–Ω–µ–π, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–µ—Ç–æ–¥–∞ –∏ –ª–æ–∫–∞—Ü–∏–∏\n\n"
    "–í–∞–º –Ω—É–∂–µ–Ω –ø—Ä–æ–¥—É–∫—Ç –∫ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π –¥–∞—Ç–µ?\n\n"
    "–ö—É–¥–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑?"
)

# === Regex pentru √ÆntrebƒÉri despre timp/termen (RO + RU) ===
ETA_PATTERNS_RO = [
    r"\b√Æn\s+c[√¢a]t\s+timp\b",
    r"\bc[√¢a]t\s+se\s+(face|realizeaz[ƒÉa]|execut[ƒÉa])\b",
    r"\bcare\s+este\s+termenul\b",
    r"\btermen(ul)?\s+de\s+(realizare|executare)\b",
    r"\b(timp|durat[ƒÉa])\s+de\s+executare\b",
]

ETA_PATTERNS_RU = [
    r"\b—á–µ—Ä–µ–∑\s+—Å–∫–æ–ª—å–∫–æ\b",
    r"\b—Å–∫–æ–ª—å–∫–æ\s+–¥–Ω(–µ–π|—è)\b",
    r"\b—Å—Ä–æ–∫(–∏)?\s+–∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏[—è–µ]\b",
    r"\b–∑–∞\s+–∫–∞–∫–æ–µ\s+–≤—Ä–µ–º—è\b",
]

ETA_REGEX = re.compile("|".join(ETA_PATTERNS_RO + ETA_PATTERNS_RU), re.IGNORECASE)

# === Anti-spam ETA: rƒÉspunde o singurƒÉ datƒÉ per conversa»õie (per user) ===
ETA_REPLIED: Dict[str, bool] = {} 

# === LIVRARE: text + trigger intent (RO+RU) ===
DELIVERY_TEXT = (
    "LivrƒÉm √Æn toatƒÉ Moldova üì¶\n\n"
    "‚úÖ √én Chi»ôinƒÉu »ôi BƒÉl»õi: prin curier personal, timp de o zi lucrƒÉtoare, din moment ce este gata comanda, direct la adresƒÉ. Cost livrare: 65 lei.\n\n"
    "‚úÖ √én alte localitƒÉ»õi:\n"
    "‚Ä¢ Prin po»ôtƒÉ ‚Äî ajunge √Æn 3 zile lucrƒÉtoare, plata la primire (cash), 65 lei livrarea.\n"
    "‚Ä¢ Prin curier ‚Äî 1/2 zile lucrƒÉtoare din momentul expedierii, plata pentru comandƒÉ se face √Æn prealabil pe card, 68 lei livrarea.\n\n"
    "Cum a»õi prefera sƒÉ facem livrarea?"
)

DELIVERY_TEXT_RU = (
    "–î–æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ –≤—Å–µ–π –ú–æ–ª–¥–æ–≤–µ üì¶\n\n"
    "‚úÖ –í –ö–∏—à–∏–Ω—ë–≤–µ –∏ –ë–µ–ª—å—Ü–∞—Ö: –∫—É—Ä—å–µ—Ä–æ–º –ª–∏—á–Ω–æ, –≤ —Ç–µ—á–µ–Ω–∏–µ 1 —Ä–∞–±–æ—á–µ–≥–æ –¥–Ω—è –ø–æ—Å–ª–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∑–∞–∫–∞–∑–∞, –ø—Ä—è–º–æ –ø–æ –∞–¥—Ä–µ—Å—É. –°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏: 65 –ª–µ–π.\n\n"
    "‚úÖ –í –¥—Ä—É–≥–∏–µ –Ω–∞—Å–µ–ª—ë–Ω–Ω—ã–µ –ø—É–Ω–∫—Ç—ã:\n"
    "‚Ä¢ –ü–æ—á—Ç–æ–π ‚Äî –¥–æ—Å—Ç–∞–≤–∫–∞ –∑–∞ 3 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è, –æ–ø–ª–∞—Ç–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ (–Ω–∞–ª–∏—á–Ω—ã–º–∏), 65 –ª–µ–π –¥–æ—Å—Ç–∞–≤–∫–∞.\n"
    "‚Ä¢ –ö—É—Ä—å–µ—Ä–æ–º ‚Äî 1/2 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è —Å –º–æ–º–µ–Ω—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏, –æ–ø–ª–∞—Ç–∞ –∑–∞–∫–∞–∑–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ –∫–∞—Ä—Ç—É, –¥–æ—Å—Ç–∞–≤–∫–∞ 68 –ª–µ–π.\n\n"
    "–ö–∞–∫ –≤–∞–º –±—ã–ª–æ –±—ã —É–¥–æ–±–Ω–µ–µ –ø–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑?"
)

# Cuvinte-cheie/√ÆntrebƒÉri pentru livrare (inten»õie explicitƒÉ), fƒÉrƒÉ a include executarea/ETA
DELIVERY_PATTERNS_RO = [
    r"\bcum\s+se\s+face\s+livrarea\b",
    r"\bcum\s+livra[»õt]i\b",                        # cum livra»õi/livrati
    r"\bmetod[ƒÉa]?\s+de\s+livrare\b",
    r"\bmodalit[ƒÉa][»õt]i\s+de\s+livrare\b",
    r"\bexpediere\b", r"\btrimite[»õt]i\b",          # ‚Äûtrimite»õi √Æn...?‚Äù, ‚Äûtrimite»õi prin...?‚Äù
    r"\blivrarea\b", r"\blivrare\b",
    r"\bcurier\b", r"\bpo[»ôs]t[ƒÉa]\b",
    r"\bcost(ul)?\s+livr[ƒÉa]rii?\b", r"\btaxa\s+de\s+livrare\b",
    r"\blivra[»õt]i\s+√Æn\b",                         # ‚Äûlivra»õi √Æn Orhei?‚Äù
    r"\bse\s+livreaz[ƒÉa]\b",
    r"\bcum\s+ajunge\b",                            # ‚Äûcum ajunge coletul?‚Äù
]
DELIVERY_PATTERNS_RU = [
    r"\b–∫–∞–∫\s+–¥–æ—Å—Ç–∞–≤–∫–∞\b", r"\b–∫–∞–∫\s+–≤—ã\s+–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ\b",
    r"\b—Å–ø–æ—Å–æ–±(—ã)?\s+–¥–æ—Å—Ç–∞–≤–∫–∏\b",
    r"\b–æ—Ç–ø—Ä–∞–≤–∫[–∞–∏]\b", r"\b–ø–µ—Ä–µ—Å—ã–ª–∫[–∞–∏]\b",
    r"\b–¥–æ—Å—Ç–∞–≤–∫[–∞–∏]\b", r"\b–∫—É—Ä—å–µ—Ä\b", r"\b–ø–æ—á—Ç[–∞—ã]\b",
    r"\b—Å—Ç–æ–∏–º–æ—Å—Ç[—å–∏]\s+–¥–æ—Å—Ç–∞–≤–∫–∏\b", r"\b—Å–∫–æ–ª—å–∫–æ\s+—Å—Ç–æ–∏—Ç\s+–¥–æ—Å—Ç–∞–≤–∫[–∞–∏]\b",
    r"\b–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ\s+–≤\b",                         # ‚Äû–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ –≤ ...?‚Äù
    r"\b–∫–∞–∫\s+–ø–æ–ª—É—á–∏—Ç—å\b",
]

DELIVERY_REGEX = re.compile("|".join(DELIVERY_PATTERNS_RO + DELIVERY_PATTERNS_RU), re.IGNORECASE)

# Anti-spam livrare: rƒÉspunde o singurƒÉ datƒÉ per user/conversa»õie
DELIVERY_REPLIED: Dict[str, bool] = {}

# === Trigger ‚ÄûmƒÉ g√¢ndesc / revin‚Äù ===
FOLLOWUP_PATTERNS_RO = [
    r"\bm[ƒÉa]\s+voi\s+g[√¢a]ndi\b",
    r"\bm[ƒÉa]\s+g[√¢a]ndesc\b",
    r"\bo\s+s[ƒÉa]\s+m[ƒÉa]\s+g[√¢a]ndesc\b",
    r"\bm[ƒÉa]\s+determin\b",
    r"\b(revin|revin\s+mai\s+t[√¢a]rziu)\b",
    r"\bv[ƒÉa]\s+anun[»õt]\b",
    r"\bdac[ƒÉa]\s+ceva\s+v[ƒÉa]\s+anun[»õt]\b",
    r"\bpoate\s+revin\b",
    r"\bdecid\s+dup[ƒÉa]\b",
    r"\bmai\s+t[√¢a]rziu\s+revin\b",
]

FOLLOWUP_PATTERNS_RU = [
    r"\b—è\s+–ø–æ–¥—É–º–∞—é\b",
    r"\b–ø–æ–¥—É–º[–∞—é–µ]\b",
    r"\b–µ—Å–ª–∏\s+—á—Ç–æ\s+—Å–æ–æ–±—â[—É–∏–º]\b",
    r"\b–¥–∞–º\s+–∑–Ω–∞—Ç—å\b",
    r"\b–ø–æ–∑–∂–µ\s+–Ω–∞–ø–∏—à[—É—é]\b",
    r"\b—Ä–µ—à[—É–∏–º]\s+–∏\s+–≤–µ—Ä–Ω—É—Å—å\b",
    r"\b–≤–µ—Ä–Ω—É—Å—å\s+–ø–æ–∑–∂–µ\b",
    r"\b–Ω–∞–ø–∏—à—É\s+–ø–æ–∑–∂–µ\b",
    r"\b–∫–∞–∫\s+—Ä–µ—à—É\s+‚Äî?\s*–Ω–∞–ø–∏—à—É\b",
]
FOLLOWUP_REGEX = re.compile("|".join(FOLLOWUP_PATTERNS_RO + FOLLOWUP_PATTERNS_RU), re.IGNORECASE)


# Anti-spam: rƒÉspunde doar o datƒÉ pe conversa»õie
FOLLOWUP_REPLIED: Dict[str, bool] = {}

# === FOLLOW-UP: c√¢nd clientul spune cƒÉ se g√¢nde»ôte »ôi revine ===
FOLLOWUP_TEXT_RO = (
    "DacƒÉ apar careva √ÆntrebƒÉri privitor la produsele noastre sau la alte lucruri legate de livrare, "
    "vƒÉ pute»õi adresa, noi mereu suntem dispu»ôi pentru a reveni cu un rƒÉspuns explicit üòä\n\n"
    "Pentru o comandƒÉ cu termen limitƒÉ rugƒÉm sƒÉ ne apela»õi din timp."
)

FOLLOWUP_TEXT_RU = (
    "–ï—Å–ª–∏ –ø–æ—è–≤—è—Ç—Å—è –≤–æ–ø—Ä–æ—Å—ã –ø–æ –Ω–∞—à–∏–º —Ç–æ–≤–∞—Ä–∞–º –∏–ª–∏ –ø–æ –¥–æ—Å—Ç–∞–≤–∫–µ, "
    "–≤—ã –º–æ–∂–µ—Ç–µ –æ–±—Ä–∞—â–∞—Ç—å—Å—è ‚Äî –º—ã –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤—ã –¥–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç–≤–µ—Ç üòä\n\n"
    "–î–ª—è –∑–∞–∫–∞–∑–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º —Å—Ä–æ–∫–æ–º –ø—Ä–æ—Å–∏–º —Å–≤—è–∑–∞—Ç—å—Å—è —Å –Ω–∞–º–∏ –∑–∞—Ä–∞–Ω–µ–µ."
)

# ---------- Helpers comune ----------
def _verify_signature() -> bool:
    """VerificƒÉ X-Hub-Signature-256 dacƒÉ APP_SECRET e setat."""
    if not APP_SECRET:
        return True
    sig = request.headers.get("X-Hub-Signature-256", "")
    if not sig.startswith("sha256="):
        return False
    digest = hmac.new(APP_SECRET.encode(), request.data, hashlib.sha256).hexdigest()
    return hmac.compare_digest(sig[7:], digest)

def _is_duplicate_mid(mid: str) -> bool:
    """Dedup DM dupƒÉ MID (5 min)."""
    now = time.time()
    last = SEEN_MIDS.get(mid, 0.0)
    if now - last < DEDUP_TTL_SEC:
        return True
    SEEN_MIDS[mid] = now
    # curƒÉ»õare ocazionalƒÉ
    for k, ts in list(SEEN_MIDS.items()):
        if now - ts > DEDUP_TTL_SEC:
            SEEN_MIDS.pop(k, None)
    return False

def _should_send_offer(sender_id: str) -> bool:
    """Anti-spam: o singurƒÉ ofertƒÉ per user √Æntr-un interval."""
    now = time.time()
    last = LAST_OFFER_AT.get(sender_id, 0.0)
    if now - last < OFFER_COOLDOWN_SEC:
        return False
    LAST_OFFER_AT[sender_id] = now
    return True

def _iter_message_events(payload: Dict) -> Iterable[Tuple[str, Dict]]:
    """
    NormalizeazƒÉ doar mesajele (NU comentariile).
    - Messenger: entry[].messaging[].message
    - Instagram Graph changes: entry[].changes[] cu value.messages[] DAR field != "comments"
    Yield: (sender_id, msg_dict)
    """
    # Messenger
    for entry in payload.get("entry", []):
        for item in entry.get("messaging", []) or []:
            sender_id = (item.get("sender") or {}).get("id")
            msg = item.get("message") or {}
            if not sender_id or not isinstance(msg, dict):
                continue
            if ("text" in msg) or ("attachments" in msg) or ("quick_reply" in msg):
                yield sender_id, msg

    # Instagram Graph (doar messages, evitƒÉm field == 'comments')
    for entry in payload.get("entry", []):
        for ch in entry.get("changes", []) or []:
            if ch.get("field") == "comments":
                continue  # skip aici; comentariile sunt tratate separat
            val = ch.get("value") or {}
            for msg in val.get("messages", []) or []:
                if not isinstance(msg, dict):
                    continue
                from_field = msg.get("from") or val.get("from") or {}
                sender_id = from_field.get("id") if isinstance(from_field, dict) else from_field
                if not sender_id:
                    continue
                # normalize attachments
                attachments = None
                if isinstance(msg.get("attachments"), list):
                    attachments = msg["attachments"]
                elif isinstance(msg.get("attachments"), dict):
                    attachments = [msg["attachments"]]
                elif isinstance(msg.get("message"), dict):
                    inner = msg["message"]
                    if isinstance(inner.get("attachments"), list):
                        attachments = inner["attachments"]
                    elif isinstance(inner.get("attachments"), dict):
                        attachments = [inner["attachments"]]
                if attachments is not None:
                    msg = dict(msg)
                    msg["attachments"] = attachments

                if ("text" in msg) or ("attachments" in msg) or ("quick_reply" in msg):
                    yield sender_id, msg

def _is_ru_text(text: str) -> bool:
    return bool(CYRILLIC_RE.search(text or ""))

# Normalizare RO (fƒÉrƒÉ diacritice)
_DIAC_MAP = str.maketrans({"ƒÉ":"a","√¢":"a","√Æ":"i","»ô":"s","≈£":"t","»õ":"t",
                           "ƒÇ":"a","√Ç":"a","√é":"i","»ò":"s","≈¢":"t","»ö":"t"})
def _norm_ro(s: str) -> str:
    s = (s or "").strip().lower().translate(_DIAC_MAP)
    return " ".join(s.split())


def _detect_offer_lang(text: str) -> str | None:
    """
    'RO' / 'RU' dacƒÉ mesajul indicƒÉ inten»õie de ofertƒÉ (pre»õ/cataloage/detalii).
    Reguli:
      1) Match direct pe expresii compuse (RO_PRICE_REGEX / RU_PRICE_REGEX) => trigger
      2) Scor lexiconic:
           - RO: (PRICE ‚à™ DETAIL) + PRODUCT  => trigger (>=1 din fiecare)
           - RU: (PRICE ‚à™ DETAIL) + PRODUCT  => trigger (>=1 din fiecare)
      3) Fallback: semn de √Æntrebare + (PRICE ‚à™ DETAIL) => trigger
    """
    if not text or not text.strip():
        return None

    has_cyr = bool(CYRILLIC_RE.search(text))
    low = (text or "").lower()
    ro_norm = _norm_ro(text)
    ro_toks = set(ro_norm.split())
    ru_toks = set(low.split())

    # 1) Expresii compuse
    if has_cyr and RU_PRICE_REGEX.search(low):
        return "RU"
    if (not has_cyr) and RO_PRICE_REGEX.search(text):
        return "RO"

    # 2) Scor lexiconic (detalii + produs sau pret + produs)
    ro_has_price_or_detail = bool(ro_toks & (RO_PRICE_TERMS | RO_DETAIL_TERMS))
    ro_has_product = bool(ro_toks & RO_PRODUCT_TERMS)

    ru_has_price_or_detail = bool(ru_toks & (RU_PRICE_TERMS | RU_DETAIL_TERMS))
    ru_has_product = bool(ru_toks & RU_PRODUCT_TERMS)

    if has_cyr:
        if ru_has_price_or_detail and ru_has_product:
            return "RU"
    else:
        if ro_has_price_or_detail and ro_has_product:
            return "RO"

    # 3) Fallback: '?'+ termeni-cheie (fƒÉrƒÉ product dacƒÉ sunt √ÆntrebƒÉri foarte scurte)
    if "?" in text:
        if has_cyr and (ru_toks & (RU_PRICE_TERMS | RU_DETAIL_TERMS)):
            return "RU"
        if (not has_cyr) and (ro_toks & (RO_PRICE_TERMS | RO_DETAIL_TERMS)):
            return "RO"

    # 4) Ultima plasƒÉ: √ÆntrebƒÉri cu ‚Äûdetalii‚Äù sau ‚Äû–ø–æ–¥—Ä–æ–±–Ω–µ–µ‚Äù
    if (ro_toks & RO_DETAIL_TERMS) and ("?" in text or ro_has_product):
        return "RO"
    if (ru_toks & RU_DETAIL_TERMS) and ("?" in text or ru_has_product):
        return "RU"

    return None


def _should_send_delivery(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RU' sau 'RO' dacƒÉ mesajul √ÆntreabƒÉ despre livrare
    »ôi nu am rƒÉspuns √ÆncƒÉ √Æn conversa»õia curentƒÉ. Altfel None.
    """
    if not text:
        return None
    if DELIVERY_REGEX.search(text):
        if DELIVERY_REPLIED.get(sender_id):
            return None
        DELIVERY_REPLIED[sender_id] = True
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _should_send_eta(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RU' sau 'RO' dacƒÉ mesajul √ÆntreabƒÉ despre termenul de executare
    »ôi nu am rƒÉspuns √ÆncƒÉ √Æn conversa»õia curentƒÉ. Altfel None.
    """
    if not text:
        return None
    if ETA_REGEX.search(text):
        if ETA_REPLIED.get(sender_id):
            return None
        ETA_REPLIED[sender_id] = True
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _should_send_followup(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RO' sau 'RU' dacƒÉ mesajul e de tip 'mƒÉ g√¢ndesc/revin'.
    AsigurƒÉ o singurƒÉ trimitere per conversa»õie (anti-spam).
    """
    if not text:
        return None
    if FOLLOWUP_REGEX.search(text):
        if FOLLOWUP_REPLIED.get(sender_id):
            return None
        FOLLOWUP_REPLIED[sender_id] = True
        # limbƒÉ: dacƒÉ textul con»õine chirilice -> RU
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _send_dm_delayed(recipient_id: str, text: str, seconds: float | None = None) -> None:
    """
    Trimite DM cu √Ænt√¢rziere fƒÉrƒÉ sƒÉ blocheze webhook-ul.
    Nu atinge antispam-ul: tu chemi func»õia DOAR dupƒÉ ce ai trecut de guard-urile _should_*.
    """
    delay = seconds if seconds is not None else random.uniform(REPLY_DELAY_MIN_SEC, REPLY_DELAY_MAX_SEC)

    def _job():
        try:
            send_instagram_message(recipient_id, text[:900])
        except Exception as e:
            app.logger.exception("Delayed DM failed: %s", e)

    t = threading.Timer(delay, _job)
    t.daemon = True  # nu »õine procesul √Æn via»õƒÉ la shutdown
    t.start()

# ---------- Routes ----------
@app.get("/health")
def health():
    return {"ok": True}, 200

# Handshake (GET /webhook)
@app.get("/webhook")
def verify_webhook():
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")
    if mode == "subscribe" and token == VERIFY_TOKEN:
        return challenge, 200
    return "Forbidden", 403

# Evenimente (POST /webhook): trateazƒÉ »ôi mesaje, »ôi comentarii
@app.post("/webhook")
def webhook():
    # (op»õional) verificare semnƒÉturƒÉ
    if not _verify_signature():
        app.logger.error("Invalid X-Hub-Signature-256")
        abort(403)

    data = request.get_json(force=True, silent=True) or {}
    app.logger.info("Incoming webhook: %s", json.dumps(data, ensure_ascii=False))

    # --- 1) Fluxul de COMENTARII (exact ca p√¢nƒÉ acum) ---
    for entry in data.get("entry", []):
        for change in entry.get("changes", []):
            if change.get("field") != "comments":
                continue  # ignorƒÉm ce nu e ‚Äûcomments‚Äù aici

            value = change.get("value", {}) or {}
            comment_id = value.get("id") or value.get("comment_id")
            text = value.get("text", "") or ""
            from_user = (value.get("from") or {}).get("id")

            app.logger.info(f"[DEBUG] Comment {comment_id} from user: {from_user}")

            # evitƒÉm self-replies
            if from_user and MY_IG_USER_ID and str(from_user) == str(MY_IG_USER_ID):
                continue
            if not comment_id:
                continue

            # DEDUP comentarii
            now = time.time()
            # curƒÉ»õare TTL
            for old_cid, ts in list(PROCESSED_COMMENTS.items()):
                if now - ts > COMMENT_TTL:
                    del PROCESSED_COMMENTS[old_cid]
            if comment_id in PROCESSED_COMMENTS:
                app.logger.info(f"[comments] Comment {comment_id} already processed, skipping")
                continue
            PROCESSED_COMMENTS[comment_id] = now
            app.logger.info(f"[comments] Processing new comment {comment_id}")

            # 1) rƒÉspuns public scurt (RO/RU)
            lang_ru = _is_ru_text(text)
            ack = ACK_PUBLIC_RU if lang_ru else ACK_PUBLIC_RO
            try:
                result = reply_public_to_comment(comment_id, ack)
                if isinstance(result, dict) and result.get("success") is False:
                    app.logger.info(f"[comments] Public reply not supported for {comment_id}, continue with private message")
            except Exception:
                app.logger.exception(f"[comments] Public reply failed for {comment_id}")

    # --- 2) Fluxul de MESAJE (DM) ‚Äî trigger ofertƒÉ + anti-spam ---
    for sender_id, msg in _iter_message_events(data):
        if msg.get("is_echo"):
            continue

        mid = msg.get("mid") or msg.get("id")
        if mid and _is_duplicate_mid(mid):
            continue

        text_in = (
            (msg.get("text"))
            or ((msg.get("message") or {}).get("text"))
            or ""
        ).strip()

        attachments = msg.get("attachments") if isinstance(msg.get("attachments"), list) else []
        app.logger.info("EVENT sender=%s text=%r attachments=%d", sender_id, text_in, len(attachments))

        # --- ETA (timp execu»õie) ‚Äî rƒÉspunde DOAR o datƒÉ per user ---
        lang_eta = _should_send_eta(sender_id, text_in)
        if lang_eta:
            try:
                msg_eta = ETA_TEXT_RU if lang_eta == "RU" else ETA_TEXT
                _send_dm_delayed(sender_id, msg_eta[:900])   
            except Exception as e:
                app.logger.exception("Failed to schedule ETA reply: %s", e)
            continue

        # --- LIVRARE (o singurƒÉ datƒÉ) ---
        lang_del = _should_send_delivery(sender_id, text_in)
        if lang_del:
            try:
                msg_del = DELIVERY_TEXT_RU if lang_del == "RU" else DELIVERY_TEXT
                _send_dm_delayed(sender_id, msg_del[:900])   
            except Exception as e:
                app.logger.exception("Failed to schedule delivery reply: %s", e)
            continue

        # --- FOLLOW-UP ‚Äî rƒÉspunde DOAR o datƒÉ ---
        lang_followup = _should_send_followup(sender_id, text_in)
        if lang_followup:
            reply = FOLLOWUP_TEXT_RU if lang_followup == "RU" else FOLLOWUP_TEXT_RO
            try:
                _send_dm_delayed(sender_id, reply[:900])     
            except Exception as e:
                app.logger.exception("Failed to schedule follow-up reply: %s", e)
            continue

        # Trigger ofertƒÉ (RO/RU) o singurƒÉ datƒÉ √Æn fereastra de cooldown
        lang = _detect_offer_lang(text_in)
        if lang and _should_send_offer(sender_id):
            offer = OFFER_TEXT_RU if lang == "RU" else OFFER_TEXT_RO
            try:
                _send_dm_delayed(sender_id, offer[:900])     
            except Exception as e:
                app.logger.exception("Failed to schedule offer: %s", e)
            continue
        
        if "?" in text_in and len(text_in) <= 160:
            app.logger.info("[OFFER_INTENT_MISSING] %r", text_in)
        # AICI po»õi adƒÉuga alte fluxuri viitoare, dacƒÉ e cazul
        # (momentan webhook-ul rƒÉm√¢ne minimal pe DM)

    return jsonify({"ok": True}), 200

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "8080")), debug=False)