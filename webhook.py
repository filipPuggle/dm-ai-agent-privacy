import os
import json
import time
import hmac
import hashlib
import logging
import re
import random
import threading
from typing import Dict, Iterable, Tuple
from flask import Flask, request, abort, jsonify

# === Importurile tale existente pentru trimitere mesaje/replies ===
from send_message import (
    send_instagram_message,           # DM to user_id
    reply_public_to_comment,          # public ack under comment (dacƒÉ platforma permite)

)
app = Flask(__name__)
logging.basicConfig(level=logging.INFO)

# === ENV (exact ca √Æn Railway) ===
VERIFY_TOKEN = os.getenv("IG_VERIFY_TOKEN", "").strip()
APP_SECRET   = os.getenv("IG_APP_SECRET", "").strip()  # op»õional, pentru semnƒÉturƒÉ
MY_IG_USER_ID = os.getenv("IG_ID", "").strip()

# === Dedup DM (MID) ‚Äî 5 minute ===
SEEN_MIDS: Dict[str, float] = {}
DEDUP_TTL_SEC = 300

# === Anti-spam ofertƒÉ (o singurƒÉ replicƒÉ per user √Æntr-un interval) ===
OFFER_COOLDOWN_SEC = int(os.getenv("OFFER_COOLDOWN_SEC", "180"))  # default 3 min
LAST_OFFER_AT: Dict[str, float] = {}  # sender_id -> epoch

# === Dedup comentarii ‚Äî 1 orƒÉ ===
PROCESSED_COMMENTS: Dict[str, float] = {}
COMMENT_TTL = 3600  # 1 orƒÉ √Æn secunde

PAYMENT_REPLIED: Dict[str, float] = {}
PAYMENT_TTL_SEC = 2 * 60 * 60

REPLY_DELAY_MIN_SEC = float(os.getenv("REPLY_DELAY_MIN_SEC", "4.0"))
REPLY_DELAY_MAX_SEC = float(os.getenv("REPLY_DELAY_MAX_SEC", "7.0"))

# === Texte ofertƒÉ ===
OFFER_TEXT_RO = (
    "Salutare üëã\n\n"
    "Avem modele pentru profesori, personalizabile cu text, care sunt la pre»õ de 650 lei\n\n"
    "Facem »ôi lucrƒÉri la comandƒÉ √Æn baza pozei, la pre»õ de 780 lei\n\n"
    "LƒÉmpile au 16 culori »ôi o telecomandƒÉ √Æn set ü•∞\n\n"
    "Primi»õi 6 luni garan»õie la toatƒÉ electronica‚ö°\n\n"
    "Pentru ce tip de lampƒÉ a»õi opta ?"
)
OFFER_TEXT_RU = (
    "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ üëã\n\n"
    "–£ –Ω–∞—Å –µ—Å—Ç—å –º–æ–¥–µ–ª–∏ –¥–ª—è —É—á–∏—Ç–µ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞—Ç—å —Å —Ç–µ–∫—Å—Ç–æ–º, –∫–æ—Ç–æ—Ä—ã–µ —Å—Ç–æ—è—Ç 650 –ª–µ–π\n\n"
    "–¢–∞–∫–∂–µ –≤—ã–ø–æ–ª–Ω—è–µ–º —Ä–∞–±–æ—Ç—ã –Ω–∞ –∑–∞–∫–∞–∑ –ø–æ —Ñ–æ—Ç–æ–≥—Ä–∞—Ñ–∏–∏, —Å—Ç–æ–∏–º–æ—Å—Ç—å ‚Äî 780 –ª–µ–π\n\n"
    "–õ–∞–º–ø—ã –∏–º–µ—é—Ç 16 —Ü–≤–µ—Ç–æ–≤ –∏ –ø—É–ª—å—Ç –≤ –∫–æ–º–ø–ª–µ–∫—Ç–µ ü•∞\n\n"
    "–í—ã –ø–æ–ª—É—á–∞–µ—Ç–µ 6 –º–µ—Å—è—Ü–µ–≤ –≥–∞—Ä–∞–Ω—Ç–∏–∏ –Ω–∞ –≤—Å—é —ç–ª–µ–∫—Ç—Ä–æ–Ω–∏–∫—É‚ö°\n\n"
    "–ö–∞–∫–æ–π —Ç–∏–ø –ª–∞–º–ø—ã –≤—ã –±—ã –≤—ã–±—Ä–∞–ª–∏?"
)

# === Mesaj public scurt sub comentariu ===
ACK_PUBLIC_RO = "BunƒÉ üëã V-am rƒÉspuns √Æn privat üíå"
ACK_PUBLIC_RU = "–ó–¥—Ä–∞–≤—Å—Ç–≤—É–π—Ç–µ üëã\n–û—Ç–≤–µ—Ç–∏–ª–∏ –≤ –ª–∏—á–Ω—ã–µ —Å–æ–æ–±—â–µ–Ω–∏—è üíå"

# === Offer intent (price/catalog/models/details) ‚Äî RO + RU extins ===
CYRILLIC_RE = re.compile(r"[\u0400-\u04FF]")

_SHORT_PRICE_RO = re.compile(r"\b(?:la\s+ce\s+)?pre[t»õ]\b", re.IGNORECASE)
_SHORT_PRICE_RU = re.compile(r"\b—Ü–µ–Ω–∞\b", re.IGNORECASE)

# RO ‚Äî termeni legati de pret
RO_PRICE_TERMS = {
    "pret","pretul","preturi","tarif","cost","costa","cat e","cat este","cat costa",
    "cat vine","cat ajunge","care e pretul","aveti preturi","oferta","oferti","price",
}

# RO ‚Äî termeni de produs / categorie
RO_PRODUCT_TERMS = {
    "lampa","lampa","lampi","lampe","lampƒÉ","lampile","modele","model","catalog","neon",
    "pentru profesori","profesori","profesor",
}

# RO ‚Äî termeni de detalii / informatii
RO_DETAIL_TERMS = {
    "detalii","mai multe detalii","informatii","informa»õii","descriere","specificatii",
    "detalii despre","vreau detalii","doresc detalii","as dori detalii","as dori informatii",
    "doresc mai multe informatii","spune-mi mai multe","spuneti-mi mai multe","mai multe info",
}

# RO ‚Äî comparatori
RO_COMPARATORS = {
    "diferit","diferite","acelasi","acela»ôi","pentru orice","toate modelele","depinde de model",
}

# RU ‚Äî termeni legati de pret
RU_PRICE_TERMS = {
    "—Ü–µ–Ω–∞","—Ü–µ–Ω—É","—Ü–µ–Ω—ã","–ø—Ä–∞–π—Å","—Å—Ç–æ–∏–º–æ—Å—Ç—å","—Å–∫–æ–ª—å–∫–æ","—Å–∫–æ–ª—å–∫–æ —Å—Ç–æ–∏—Ç",
    "—Å–∫–æ–ª—å–∫–æ —Ü–µ–Ω–∞","—Å–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç","–ø–æ —á–µ–º","–ø–æ—á–µ–º","—É–∑–Ω–∞—Ç—å —Ü–µ–Ω—É",
    "—Å–∫–æ–ª—å–∫–æ –±—É–¥–µ—Ç —Å—Ç–æ–∏—Ç—å","—Å–∫ —Å–∫–æ–ª—å–∫–æ",
}

# Pentru √ÆntrebƒÉri scurte de pre»õ (acceptƒÉ »ôi ¬´—Ü–µ–Ω—É¬ª)
_SHORT_PRICE_RU = re.compile(r"\b(?:—Ü–µ–Ω[–∞—É—ã–µ]|—Å–∫–æ–ª—å–∫–æ)\b", re.IGNORECASE)
# RU ‚Äî termeni de produs / categorie
RU_PRODUCT_TERMS = {
    "–ª–∞–º–ø–∞","–ª–∞–º–ø—ã","–º–æ–¥–µ–ª—å","–º–æ–¥–µ–ª–∏","–∫–∞—Ç–∞–ª–æ–≥","–¥–ª—è —É—á–∏—Ç–µ–ª—è","—É—á–∏—Ç–µ–ª—é","—É—á–∏—Ç–µ–ª—è–º","–Ω–µ–æ–Ω",
}

# RU ‚Äî detalii/informa»õii
RU_DETAIL_TERMS = {
    "–ø–æ–¥—Ä–æ–±–Ω–µ–µ","–¥–µ—Ç–∞–ª–∏","—Ö–æ—á—É –¥–µ—Ç–∞–ª–∏","—Ä–∞—Å—Å–∫–∞–∂–∏—Ç–µ –ø–æ–¥—Ä–æ–±–Ω–µ–µ","–º–æ–∂–Ω–æ –ø–æ–¥—Ä–æ–±–Ω–µ–µ",
    "–±–æ–ª—å—à–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏","—É–∑–Ω–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω–µ–µ","–∏–Ω—Ñ–æ","–∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è",
}

# RU ‚Äî comparatori
RU_COMPARATORS = {
    "—Ä–∞–∑–Ω–∞—è","—Ä–∞–∑–Ω—ã–µ","–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è","–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è —Ü–µ–Ω–∞","–¥–ª—è –≤—Å–µ—Ö –º–æ–¥–µ–ª–µ–π","–∑–∞–≤–∏—Å–∏—Ç –æ—Ç –º–æ–¥–µ–ª–∏",
}

# Expresii compuse (ancore clare)
RO_PRICE_REGEX = re.compile(
    r"(care\s+e\s+pretul|sunt\s+preturi\s+diferite|acelasi\s+pret|pret\s+pe\s+model|pret\s+pentru\s+orice\s+model|la\s+ce\s+pret)",
    re.IGNORECASE,
)
RU_PRICE_REGEX = re.compile(
    r"(—Ü–µ–Ω–∞\s+–¥–ª—è\s+–≤—Å–µ—Ö\s+–º–æ–¥–µ–ª–µ–π|—Ä–∞–∑–Ω–∞—è\s+—Ü–µ–Ω–∞|–æ–¥–∏–Ω–∞–∫–æ–≤–∞—è\s+—Ü–µ–Ω–∞|—Ü–µ–Ω–∞\s+–∑–∞\s+–º–æ–¥–µ–ª—å|–º–æ–∂–Ω–æ\s+—É–∑–Ω–∞—Ç—å\s+—Ü–µ–Ω—É)",
    re.IGNORECASE,
)


ETA_TEXT = (
    "Lucrarea se elaboreazƒÉ timp de 3-4 zile lucrƒÉtoare\n\n"
    "Livrarea dureazƒÉ de la o zi p√¢nƒÉ la trei zile independent de metodƒÉ »ôi loca»õie\n\n"
    "A»õi avea nevoie de produs pentru o anumitƒÉ datƒÉ?\n\n"
    "Unde va trebui de livrat produsul?"
)

ETA_TEXT_RU = (
    "–ò–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏–µ –∏–∑–¥–µ–ª–∏—è –∑–∞–Ω–∏–º–∞–µ—Ç 3-4 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è\n\n"
    "–î–æ—Å—Ç–∞–≤–∫–∞ –¥–ª–∏—Ç—Å—è –æ—Ç –æ–¥–Ω–æ–≥–æ –¥–æ —Ç—Ä—ë—Ö –¥–Ω–µ–π, –≤ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –æ—Ç –º–µ—Ç–æ–¥–∞ –∏ –ª–æ–∫–∞—Ü–∏–∏\n\n"
    "–í–∞–º –Ω—É–∂–µ–Ω –ø—Ä–æ–¥—É–∫—Ç –∫ –æ–ø—Ä–µ–¥–µ–ª—ë–Ω–Ω–æ–π –¥–∞—Ç–µ?\n\n"
    "–ö—É–¥–∞ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ –±—É–¥–µ—Ç –¥–æ—Å—Ç–∞–≤–∏—Ç—å –∑–∞–∫–∞–∑?"
)

# === Regex pentru √ÆntrebƒÉri despre timp/termen (RO + RU) ===
ETA_PATTERNS_RO = [
    r"\b√Æn\s+c[√¢a]t\s+timp\b",
    r"\bc[√¢a]t\s+se\s+(face|realizeaz[ƒÉa]|execut[ƒÉa])\b",
    r"\bcare\s+este\s+termenul\b",
    r"\btermen(ul)?\s+de\s+(realizare|executare)\b",
    r"\b(timp|durat[ƒÉa])\s+de\s+executare\b",
]

ETA_PATTERNS_RU = [
    r"\b—á–µ—Ä–µ–∑\s+—Å–∫–æ–ª—å–∫–æ\b",
    r"\b—Å–∫–æ–ª—å–∫–æ\s+–¥–Ω(?:–µ–π|—è)\b",
    r"\b—Å—Ä–æ–∫(?:–∏)?\s+–∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏[—è–µ]\b",
    r"\b–∑–∞\s+–∫–∞–∫–æ–µ\s+–≤—Ä–µ–º—è\b",
    # ‚Äî extinderi uzuale/colocviale ‚Äî
    r"\b—á—Ç–æ\s+–ø–æ\s+—Å—Ä–æ–∫–∞–º\??",                 # –ß—Ç–æ –ø–æ —Å—Ä–æ–∫–∞–º?
    r"\b–∫–∞–∫–∏–µ\s+—Å—Ä–æ–∫–∏\??",                     # –ö–∞–∫–∏–µ —Å—Ä–æ–∫–∏?
    r"\b–∫–∞–∫–∏–µ\s+—Å—Ä–æ–∫–∏\s+–∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏[—è–µ]\??",   # –ö–∞–∫–∏–µ —Å—Ä–æ–∫–∏ –∏–∑–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è?
    r"\b–ø–æ\s+–≤—Ä–µ–º–µ–Ω–∏\s+–∫–∞–∫\??",                # –ü–æ –≤—Ä–µ–º–µ–Ω–∏ –∫–∞–∫?
    r"\b–∫\s+–∫–∞–∫–æ–º[—É—ã]\s+—á–∏—Å–ª[—É—ã]\??",          # –ö –∫–∞–∫–æ–º—É —á–∏—Å–ª—É?
    r"\b—É—Å–ø–µ–µ—Ç[–µ]?\s+–∫\s+\d{1,2}\.?(\s*[–∞-—è]+)?",   # –£—Å–ø–µ–µ—Ç–µ –∫ 15/–∫ 15 –º–∞—è
    r"\b—Å—Ä–æ–∫[–∏]?\b",                           # –æ–¥–∏–Ω–æ—á–Ω–æ–µ ¬´—Å—Ä–æ–∫–∏?¬ª
    r"\b–ø–æ\s+—Å—Ä–æ–∫–∞–º\b",                        # ¬´–ø–æ —Å—Ä–æ–∫–∞–º¬ª
    
]

ETA_REGEX = re.compile("|".join(ETA_PATTERNS_RO + ETA_PATTERNS_RU), re.IGNORECASE)

# === Anti-spam ETA: rƒÉspunde o singurƒÉ datƒÉ per conversa»õie (per user) ===
ETA_REPLIED: Dict[str, bool] = {} 

# === LIVRARE: text + trigger intent (RO+RU) ===
DELIVERY_TEXT = (
    "LivrƒÉm √Æn toatƒÉ Moldova üì¶\n\n"
    "‚úÖ √én Chi»ôinƒÉu »ôi BƒÉl»õi: prin curier personal, timp de o zi lucrƒÉtoare, din moment ce este gata comanda, direct la adresƒÉ. Cost livrare: 65 lei.\n\n"
    "‚úÖ √én alte localitƒÉ»õi:\n"
    "‚Ä¢ Prin po»ôtƒÉ ‚Äî ajunge √Æn 3 zile lucrƒÉtoare, plata la primire (cash), 65 lei livrarea.\n"
    "‚Ä¢ Prin curier ‚Äî 1/2 zile lucrƒÉtoare din momentul expedierii, plata pentru comandƒÉ se face √Æn prealabil pe card, 68 lei livrarea.\n\n"
    "Cum a»õi prefera sƒÉ facem livrarea?"
)

DELIVERY_TEXT_RU = (
    "–î–æ—Å—Ç–∞–≤–ª—è–µ–º –ø–æ –≤—Å–µ–π –ú–æ–ª–¥–æ–≤–µ üì¶\n\n"
    "‚úÖ –í –ö–∏—à–∏–Ω—ë–≤–µ –∏ –ë–µ–ª—å—Ü–∞—Ö: –∫—É—Ä—å–µ—Ä–æ–º –ª–∏—á–Ω–æ, –≤ —Ç–µ—á–µ–Ω–∏–µ 1 —Ä–∞–±–æ—á–µ–≥–æ –¥–Ω—è –ø–æ—Å–ª–µ –≥–æ—Ç–æ–≤–Ω–æ—Å—Ç–∏ –∑–∞–∫–∞–∑–∞, –ø—Ä—è–º–æ –ø–æ –∞–¥—Ä–µ—Å—É. –°—Ç–æ–∏–º–æ—Å—Ç—å –¥–æ—Å—Ç–∞–≤–∫–∏: 65 –ª–µ–π.\n\n"
    "‚úÖ –í –¥—Ä—É–≥–∏–µ –Ω–∞—Å–µ–ª—ë–Ω–Ω—ã–µ –ø—É–Ω–∫—Ç—ã:\n"
    "‚Ä¢ –ü–æ—á—Ç–æ–π ‚Äî –¥–æ—Å—Ç–∞–≤–∫–∞ –∑–∞ 3 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è, –æ–ø–ª–∞—Ç–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ (–Ω–∞–ª–∏—á–Ω—ã–º–∏), 65 –ª–µ–π –¥–æ—Å—Ç–∞–≤–∫–∞.\n"
    "‚Ä¢ –ö—É—Ä—å–µ—Ä–æ–º ‚Äî 1/2 —Ä–∞–±–æ—á–∏—Ö –¥–Ω—è —Å –º–æ–º–µ–Ω—Ç–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏, –æ–ø–ª–∞—Ç–∞ –∑–∞–∫–∞–∑–∞ –ø—Ä–µ–¥–≤–∞—Ä–∏—Ç–µ–ª—å–Ω–æ –Ω–∞ –∫–∞—Ä—Ç—É, –¥–æ—Å—Ç–∞–≤–∫–∞ 68 –ª–µ–π.\n\n"
    "–ö–∞–∫ –≤–∞–º –±—ã–ª–æ –±—ã —É–¥–æ–±–Ω–µ–µ –ø–æ–ª—É—á–∏—Ç—å –∑–∞–∫–∞–∑?"
)

# Cuvinte-cheie/√ÆntrebƒÉri pentru livrare (inten»õie explicitƒÉ), fƒÉrƒÉ a include executarea/ETA
DELIVERY_PATTERNS_RO = [
    r"\bcum\s+se\s+face\s+livrarea\b",
    r"\bcum\s+livra[»õt]i\b",                        # cum livra»õi/livrati
    r"\bmetod[ƒÉa]?\s+de\s+livrare\b",
    r"\bmodalit[ƒÉa][»õt]i\s+de\s+livrare\b",
    r"\bexpediere\b", r"\btrimite[»õt]i\b",          # ‚Äûtrimite»õi √Æn...?‚Äù, ‚Äûtrimite»õi prin...?‚Äù
    r"\blivrarea\b", r"\blivrare\b",
    r"\bcurier\b", r"\bpo[»ôs]t[ƒÉa]\b",
    r"\bcost(ul)?\s+livr[ƒÉa]rii?\b", r"\btaxa\s+de\s+livrare\b",
    r"\blivra[»õt]i\s+√Æn\b",                         # ‚Äûlivra»õi √Æn Orhei?‚Äù
    r"\bse\s+livreaz[ƒÉa]\b",
    r"\bcum\s+ajunge\b",                            # ‚Äûcum ajunge coletul?‚Äù
]
DELIVERY_PATTERNS_RU = [
    r"\b–∫–∞–∫\s+–¥–æ—Å—Ç–∞–≤–∫–∞\b", r"\b–∫–∞–∫\s+–≤—ã\s+–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ\b",
    r"\b—Å–ø–æ—Å–æ–±(—ã)?\s+–¥–æ—Å—Ç–∞–≤–∫–∏\b",
    r"\b–æ—Ç–ø—Ä–∞–≤–∫[–∞–∏]\b", r"\b–ø–µ—Ä–µ—Å—ã–ª–∫[–∞–∏]\b",
    r"\b–¥–æ—Å—Ç–∞–≤–∫[–∞–∏]\b", r"\b–∫—É—Ä—å–µ—Ä\b", r"\b–ø–æ—á—Ç[–∞—ã]\b",
    r"\b—Å—Ç–æ–∏–º–æ—Å—Ç[—å–∏]\s+–¥–æ—Å—Ç–∞–≤–∫–∏\b", r"\b—Å–∫–æ–ª—å–∫–æ\s+—Å—Ç–æ–∏—Ç\s+–¥–æ—Å—Ç–∞–≤–∫[–∞–∏]\b",
    r"\b–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ\s+–≤\b",                         # ‚Äû–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç–µ –≤ ...?‚Äù
    r"\b–∫–∞–∫\s+–ø–æ–ª—É—á–∏—Ç—å\b",
]

DELIVERY_REGEX = re.compile("|".join(DELIVERY_PATTERNS_RO + DELIVERY_PATTERNS_RU), re.IGNORECASE)

# Anti-spam livrare: rƒÉspunde o singurƒÉ datƒÉ per user/conversa»õie
DELIVERY_REPLIED: Dict[str, bool] = {}

# === Trigger ‚ÄûmƒÉ g√¢ndesc / revin‚Äù ===
FOLLOWUP_PATTERNS_RO = [
    r"\bm[ƒÉa]\s+voi\s+g[√¢a]ndi\b",
    r"\bm[ƒÉa]\s+g[√¢a]ndesc\b",
    r"\bo\s+s[ƒÉa]\s+m[ƒÉa]\s+g[√¢a]ndesc\b",
    r"\bm[ƒÉa]\s+determin\b",
    r"\b(revin|revin\s+mai\s+t[√¢a]rziu)\b",
    r"\bv[ƒÉa]\s+anun[»õt]\b",
    r"\bdac[ƒÉa]\s+ceva\s+v[ƒÉa]\s+anun[»õt]\b",
    r"\bpoate\s+revin\b",
    r"\bdecid\s+dup[ƒÉa]\b",
    r"\bmai\s+t[√¢a]rziu\s+revin\b",
]

FOLLOWUP_PATTERNS_RU = [
    r"\b—è\s+–ø–æ–¥—É–º–∞—é\b",
    r"\b–ø–æ–¥—É–º[–∞—é–µ]\b",
    r"\b–µ—Å–ª–∏\s+—á—Ç–æ\s+—Å–æ–æ–±—â[—É–∏–º]\b",
    r"\b–¥–∞–º\s+–∑–Ω–∞—Ç—å\b",
    r"\b–ø–æ–∑–∂–µ\s+–Ω–∞–ø–∏—à[—É—é]\b",
    r"\b—Ä–µ—à[—É–∏–º]\s+–∏\s+–≤–µ—Ä–Ω—É—Å—å\b",
    r"\b–≤–µ—Ä–Ω—É—Å—å\s+–ø–æ–∑–∂–µ\b",
    r"\b–Ω–∞–ø–∏—à—É\s+–ø–æ–∑–∂–µ\b",
    r"\b–∫–∞–∫\s+—Ä–µ—à—É\s+‚Äî?\s*–Ω–∞–ø–∏—à—É\b",
]
FOLLOWUP_REGEX = re.compile("|".join(FOLLOWUP_PATTERNS_RO + FOLLOWUP_PATTERNS_RU), re.IGNORECASE)


# Anti-spam: rƒÉspunde doar o datƒÉ pe conversa»õie
FOLLOWUP_REPLIED: Dict[str, bool] = {}

# === FOLLOW-UP: c√¢nd clientul spune cƒÉ se g√¢nde»ôte »ôi revine ===
FOLLOWUP_TEXT_RO = (
    "DacƒÉ apar careva √ÆntrebƒÉri privitor la produsele noastre sau la alte lucruri legate de livrare, "
    "vƒÉ pute»õi adresa, noi mereu suntem dispu»ôi pentru a reveni cu un rƒÉspuns explicit üòä\n\n"
    "Pentru o comandƒÉ cu termen limitƒÉ rugƒÉm sƒÉ ne apela»õi din timp."
)

FOLLOWUP_TEXT_RU = (
    "–ï—Å–ª–∏ –ø–æ—è–≤—è—Ç—Å—è –≤–æ–ø—Ä–æ—Å—ã –ø–æ –Ω–∞—à–∏–º —Ç–æ–≤–∞—Ä–∞–º –∏–ª–∏ –ø–æ –¥–æ—Å—Ç–∞–≤–∫–µ, "
    "–≤—ã –º–æ–∂–µ—Ç–µ –æ–±—Ä–∞—â–∞—Ç—å—Å—è ‚Äî –º—ã –≤—Å–µ–≥–¥–∞ –≥–æ—Ç–æ–≤—ã –¥–∞—Ç—å –ø–æ–¥—Ä–æ–±–Ω—ã–π –æ—Ç–≤–µ—Ç üòä\n\n"
    "–î–ª—è –∑–∞–∫–∞–∑–∞ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–Ω—ã–º —Å—Ä–æ–∫–æ–º –ø—Ä–æ—Å–∏–º —Å–≤—è–∑–∞—Ç—å—Å—è —Å –Ω–∞–º–∏ –∑–∞—Ä–∞–Ω–µ–µ."
)

# === ACHITARE / PAYMENT: text + trigger intent (RO+RU) ===
PAYMENT_TEXT_RO = (
    "Punem accent pe achitare la primire, √ÆnsƒÉ √Æn cazul lucrƒÉrilor personalizate este nevoie de un avans."
)

PAYMENT_TEXT_RU = (
    "–û–±—ã—á–Ω–æ –æ–ø–ª–∞—Ç–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏, –Ω–æ –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç —Ç—Ä–µ–±—É–µ—Ç—Å—è –ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ (–∞–≤–∞–Ω—Å)."
)

# RO ‚Äî √ÆntrebƒÉri / fraze despre platƒÉ/achitare
PAYMENT_PATTERNS_RO = [
    r"\bcum\s+se\s+face\s+achitarea\b",
    r"\bcum\s+se\s+face\s+plata\b",
    r"\bcum\s+pl[ƒÉa]tesc\b",
    r"\bmetod[ƒÉa]?\s+de\s+pl[ƒÉa]t[ƒÉa]\b",
    r"\bmodalit[ƒÉa][»õt]i\s+de\s+pl[ƒÉa]t[ƒÉa]\b",
    r"\bachitare\b", r"\bpl[ƒÉa]t[ƒÉa]\b",
    r"\bplata\s+la\s+livrare\b", r"\bramburs\b", r"\bnumerar\b",
    r"\btransfer\b", r"\bpe\s+card\b", r"\bcard\b",
    r"\bavans\b", r"\bprepl[ƒÉa]t[ƒÉa]\b", r"\bprepay\b",r"\bavans(ul)?\b",
]

# RU ‚Äî √ÆntrebƒÉri / fraze despre platƒÉ/–æ–ø–ª–∞—Ç–∞
PAYMENT_PATTERNS_RU = [
    r"\b–∫–∞–∫\s+–æ–ø–ª–∞—Ç–∏—Ç—å\b",
    r"\b–∫–∞–∫\s+–ø—Ä–æ–∏—Å—Ö–æ–¥–∏—Ç\s+–æ–ø–ª–∞—Ç–∞\b",
    r"\b—Å–ø–æ—Å–æ–±(—ã)?\s+–æ–ø–ª–∞—Ç—ã\b",
    r"\b–æ–ø–ª–∞—Ç[–∞–∏]\b", r"\b–æ–ø–ª–∞—Ç–∞\b",
    r"\b–æ–ø–ª–∞—Ç–∞\s+–ø—Ä–∏\s+–ø–æ–ª—É—á–µ–Ω–∏[–∏—é]\b", r"\b–Ω–∞–ª–∏—á–Ω—ã–º–∏\b",
    r"\b–∫–∞—Ä—Ç–æ–π\b", r"\b–æ–ø–ª–∞—Ç–∞\s+–∫–∞—Ä—Ç–æ–π\b",
    r"\b–ø–µ—Ä–µ–≤–æ–¥(–æ–º)?\s+–Ω–∞\s+–∫–∞—Ä—Ç—É\b", r"\b–ø–µ—Ä–µ–≤–æ–¥\b",
    r"\b–ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞\b", r"\b–∞–≤–∞–Ω—Å\b",
    r"\b–∫–∞–∫\s+–±—É–¥–µ—Ç\s+–æ–ø–ª–∞—Ç–∞\b", r"\b–æ–ø–ª–∞—Ç–∞\s+–∫–∞–∫\b",
]

PAYMENT_REGEX = re.compile("|".join(PAYMENT_PATTERNS_RO + PAYMENT_PATTERNS_RU), re.IGNORECASE)

# Anti-spam platƒÉ: o singurƒÉ datƒÉ per user/conversa»õie
# ‚Äî AVANS / PREPAY exact amount ‚Äî
ADVANCE_TEXT_RO = (
    "Avansul e √Æn sumƒÉ de 200 lei, se achitƒÉ doar pentru lucrƒÉrile personalizate!"
)

ADVANCE_TEXT_RU = (
    "–ü—Ä–µ–¥–æ–ø–ª–∞—Ç–∞ —Å–æ—Å—Ç–∞–≤–ª—è–µ—Ç 200 –ª–µ–π –∏ —Ç—Ä–µ–±—É–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –¥–ª—è –ø–µ—Ä—Å–æ–Ω–∞–ª–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã—Ö —Ä–∞–±–æ—Ç!"
)

# RO ‚Äî √ÆntrebƒÉri specifice despre avans
ADVANCE_PATTERNS_RO = [
    r"\b(avansul|avans)\b",
    r"\beste\s+nevoie\s+de\s+avans\b",
    r"\btrebuie\s+avans\b",
    r"\bc[√¢a]t\s+avans(ul)?\b",                      # c√¢t e avansul?
    r"\bsuma\s+avans(ului)?\b",
    r"\bc[√¢a]t\s+trebuie\s+s[ƒÉa]\s+achit\b.*avans", # c√¢t trebuie sƒÉ achit avans?
    r"\bprepl[ƒÉa]t[ƒÉa]\b",                          # preplatƒÉ (rom/rus mix folosit)
]

# RU ‚Äî √ÆntrebƒÉri specifice despre –ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞/–∞–≤–∞–Ω—Å
ADVANCE_PATTERNS_RU = [
    r"\b–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[–∞—ã]\b",
    r"\b–Ω—É–∂–Ω[–∞—ã]\s+–ª–∏\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞\b",
    r"\b–Ω—É–∂–µ–Ω\s+–ª–∏\s+–∞–≤–∞–Ω—Å\b",
    r"\b–∞–≤–∞–Ω—Å\b",
    r"\b—Å–∫–æ–ª—å–∫–æ\s+(?:–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[–∞—ã]|–∞–≤–∞–Ω—Å[–∞]?)\b",   # —Å–∫–æ–ª—å–∫–æ –ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞? / —Å–∫–æ–ª—å–∫–æ –∞–≤–∞–Ω—Å–∞?
    r"\b—Ä–∞–∑–º–µ—Ä\s+(?:–ø—Ä–µ–¥–æ–ø–ª–∞—Ç—ã|–∞–≤–∞–Ω—Å–∞)\b",
    r"\b—Å–∫–æ–ª—å–∫–æ\s+–Ω—É–∂–Ω–æ\s+–≤–Ω–µ—Å—Ç–∏\b",
    r"\b–Ω–∞–¥–æ\s+–ª–∏\s+–≤–Ω–æ—Å–∏—Ç—å\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç—É\b",
]
ADVANCE_REGEX = re.compile("|".join(ADVANCE_PATTERNS_RO + ADVANCE_PATTERNS_RU), re.IGNORECASE)


# ‚Äî AVANS: √ÆntrebƒÉri despre SUMƒÇ (RO / RU) ‚Äî
ADVANCE_AMOUNT_PATTERNS_RO = [
    r"\bc[√¢a]t\s+(?:e|este)\s+avans(ul)?\b",
    r"\bc[√¢a]t\s+avans(ul)?\b",
    r"\bcare\s+e\s+suma\s+(?:de\s+)?avans(ului)?\b",
    r"\bce\s+suma\s+are\s+avansul\b",
    r"\bsuma\s+avans(ului)?\b",
    r"\bavansul\s+(?:de|este)\s*\?\b",
    r"\bavans\s+(?:de|este)\s+\d+\b",
]

ADVANCE_AMOUNT_PATTERNS_RU = [
    r"\b—Å–∫–æ–ª—å–∫–æ\s+(?:–Ω—É–∂–Ω–æ\s+)?–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[—ã—ã—É]\b",
    r"\b–∫–∞–∫–∞—è\s+—Å—É–º–º–∞\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[—ã—ã]\b",
    r"\b–∫–∞–∫–æ[–π—è]\s+—Ä–∞–∑–º–µ—Ä\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[—ã—ã]\b",
    r"\b—Å–∫–æ–ª—å–∫–æ\s+–∞–≤–∞–Ω—Å\b",
    r"\b–∞–≤–∞–Ω—Å\s+—Å–∫–æ–ª—å–∫–æ\b",
    r"\b—Å—É–º–º–∞\s+–∞–≤–∞–Ω—Å–∞\b",
]
ADVANCE_AMOUNT_REGEX = re.compile("|".join(ADVANCE_AMOUNT_PATTERNS_RO + ADVANCE_AMOUNT_PATTERNS_RU), re.IGNORECASE)

# ‚Äî AVANS: metoda de platƒÉ (RO / RU) ‚Äî
ADVANCE_METHOD_TEXT_RO = (
    "Avansul se poate achita prin transfer pe card.\n\n"
    "5397 0200 6122 9082 cont MAIB\n\n"
    "062176586 MIA plƒÉ»õi instant\n\n"
    "DupƒÉ transfer, expedia»õi o pozƒÉ a chitan»õei, pentru confirmarea transferului."
)

ADVANCE_METHOD_TEXT_RU = (
    "–ü—Ä–µ–¥–æ–ø–ª–∞—Ç—É –º–æ–∂–Ω–æ –≤–Ω–µ—Å—Ç–∏ –ø–µ—Ä–µ–≤–æ–¥–æ–º –Ω–∞ –∫–∞—Ä—Ç—É.\n\n"
    "5397 0200 6122 9082 (—Å—á—ë—Ç MAIB)\n\n"
    "062176586 MIA ‚Äî –º–≥–Ω–æ–≤–µ–Ω–Ω—ã–µ –ø–ª–∞—Ç–µ–∂–∏\n\n"
    "–ü–æ—Å–ª–µ –ø–µ—Ä–µ–≤–æ–¥–∞, –ø–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ—Ç–ø—Ä–∞–≤—å—Ç–µ —Ñ–æ—Ç–æ –∫–≤–∏—Ç–∞–Ω—Ü–∏–∏ –¥–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏—è."
)

# RO ‚Äî cum se achitƒÉ avansul (metodƒÉ / detalii card)
ADVANCE_METHOD_PATTERNS_RO = [
    r"\bcum\s+se\s+poate\s+achita\s+avansul\b",
    r"\bcum\s+pl[ƒÉa]tesc\s+avansul\b",
    r"\bmetod[ƒÉa]?\s+de\s+pl[ƒÉa]t[ƒÉa]\s+pentru\s+avans\b",
    r"\bachitare\s+avans\b", r"\bplata\s+avansului\b",
    r"\btransfer\s+pe\s+card\b", r"\bpe\s+card\s+avans\b",
    r"\bpot\s+pl[ƒÉa]ti\s+avansul\s+cu\s+card(ul)?\b",
    r"\bdetalii\s+card\b", r"\bdate\s+card\b",
    r"\brechizite\b", r"\bnum[aƒÉ]r\s+de\s+card\b",
    r"\bunde\s+pot\s+pl[ƒÉa]ti\s+avansul\b",
    r"\bcont\s+maib\b", r"\bpl[ƒÉa]»õi\s+instant\b", r"\bplati\s+instant\b",
]

# RU ‚Äî –∫–∞–∫ –æ–ø–ª–∞—Ç–∏—Ç—å –ø—Ä–µ–¥–æ–ø–ª–∞—Ç—É (–º–µ—Ç–æ–¥ / —Ä–µ–∫–≤–∏–∑–∏—Ç—ã)
ADVANCE_METHOD_PATTERNS_RU = [
    r"\b–∫–∞–∫\s+(?:–æ–ø–ª–∞—Ç–∏—Ç—å|–≤–Ω–µ—Å—Ç–∏)\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[–∞—É]\b",
    r"\b–∫–∞–∫\s+(?:–æ–ø–ª–∞—Ç–∏—Ç—å|–≤–Ω–µ—Å—Ç–∏)\s+–∞–≤–∞–Ω—Å\b",
    r"\b–æ–ø–ª–∞—Ç–∞\s+–∞–≤–∞–Ω—Å[–∞]?\b", r"\b–ø—Ä–µ–¥–æ–ø–ª–∞—Ç–∞\s+–∫–∞–∫\b",
    r"\b–ø–µ—Ä–µ–≤–æ–¥\s+–Ω–∞\s+–∫–∞—Ä—Ç—É\b", r"\b–∫–∞—Ä—Ç–æ–π\s+–º–æ–∂–Ω–æ\b",
    r"\b—Ä–µ–∫–≤–∏–∑–∏—Ç[—ã–∞]\b", r"\b–Ω–æ–º–µ—Ä\s+–∫–∞—Ä—Ç—ã\b",
    r"\b–∫—É–¥–∞\s+–ø–µ—Ä–µ–≤–µ—Å—Ç[—å–∏]\b", r"\b–∫–∞–∫\s+—Å–¥–µ–ª–∞—Ç—å\s+–ø–µ—Ä–µ–≤–æ–¥\b",
    r"\b–∫—É–¥–∞\s+–æ–ø–ª–∞—Ç–∏—Ç—å\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç[—É—ã]\b",
    r"\b—Ä–µ–∫–≤–∏–∑–∏—Ç—ã\s+–¥–ª—è\s+–ø—Ä–µ–¥–æ–ø–ª–∞—Ç—ã\b",
    r"\b–º–≥–Ω–æ–≤–µ–Ω–Ω[–∞—ã]–µ\s+–ø–ª–∞—Ç–µ–∂–∏\b",
]
ADVANCE_METHOD_REGEX = re.compile("|".join(ADVANCE_METHOD_PATTERNS_RO + ADVANCE_METHOD_PATTERNS_RU), re.IGNORECASE)

_AMOUNT_HINT_RE = re.compile(r"\b(c[√¢a]t|suma|lei)\b|\d{2,}", re.IGNORECASE)

def _select_payment_message(lang: str, text: str) -> str:
    """
    Selector pentru tema 'platƒÉ':
      1) dacƒÉ e √Æntrebare despre SUMA avansului -> 200 lei
      2) dacƒÉ e √Æntrebare despre METODA de achitare -> detalii card
      3) altfel -> mesajul general despre platƒÉ
    """
    low = (text or "").lower()
    has_cyr = bool(CYRILLIC_RE.search(low))

    # 1) SUMA avansului (prioritar)
    if ADVANCE_AMOUNT_REGEX.search(low):
        return ADVANCE_TEXT_RU if has_cyr or lang == "RU" else ADVANCE_TEXT_RO

    # Guard: ‚Äúavans‚Äù + (c√¢t/sumƒÉ/lei/numƒÉr) -> trateazƒÉ ca SUMƒÇ
    if ("avans" in low or "–ø—Ä–µ–¥–æ–ø–ª–∞—Ç" in low or "–∞–≤–∞–Ω—Å" in low) and _AMOUNT_HINT_RE.search(low):
        return ADVANCE_TEXT_RU if has_cyr or lang == "RU" else ADVANCE_TEXT_RO

    # 2) METODA de achitare a avansului (card/rechizite)
    if ADVANCE_METHOD_REGEX.search(low):
        return ADVANCE_METHOD_TEXT_RU if has_cyr or lang == "RU" else ADVANCE_METHOD_TEXT_RO

    # 3) General "cum se face achitarea?"
    return PAYMENT_TEXT_RU if has_cyr or lang == "RU" else PAYMENT_TEXT_RO


# ---------- Helpers comune ----------
def _verify_signature() -> bool:
    """VerificƒÉ X-Hub-Signature-256 dacƒÉ APP_SECRET e setat."""
    if not APP_SECRET:
        return True
    sig = request.headers.get("X-Hub-Signature-256", "")
    if not sig.startswith("sha256="):
        return False
    digest = hmac.new(APP_SECRET.encode(), request.data, hashlib.sha256).hexdigest()
    return hmac.compare_digest(sig[7:], digest)

def _is_duplicate_mid(mid: str) -> bool:
    """Dedup DM dupƒÉ MID (5 min)."""
    now = time.time()
    last = SEEN_MIDS.get(mid, 0.0)
    if now - last < DEDUP_TTL_SEC:
        return True
    SEEN_MIDS[mid] = now
    # curƒÉ»õare ocazionalƒÉ
    for k, ts in list(SEEN_MIDS.items()):
        if now - ts > DEDUP_TTL_SEC:
            SEEN_MIDS.pop(k, None)
    return False

def _should_send_offer(sender_id: str) -> bool:
    """Anti-spam: o singurƒÉ ofertƒÉ per user √Æntr-un interval."""
    now = time.time()
    last = LAST_OFFER_AT.get(sender_id, 0.0)
    if now - last < OFFER_COOLDOWN_SEC:
        return False
    LAST_OFFER_AT[sender_id] = now
    return True

def _iter_message_events(payload: Dict) -> Iterable[Tuple[str, Dict]]:
    """
    NormalizeazƒÉ doar mesajele (NU comentariile).
    - Messenger: entry[].messaging[].message
    - Instagram Graph changes: entry[].changes[] cu value.messages[] DAR field != "comments"
    Yield: (sender_id, msg_dict)
    """
    # Messenger
    for entry in payload.get("entry", []):
        for item in entry.get("messaging", []) or []:
            sender_id = (item.get("sender") or {}).get("id")
            msg = item.get("message") or {}
            if not sender_id or not isinstance(msg, dict):
                continue
            if ("text" in msg) or ("attachments" in msg) or ("quick_reply" in msg):
                yield sender_id, msg

    # Instagram Graph (doar messages, evitƒÉm field == 'comments')
    for entry in payload.get("entry", []):
        for ch in entry.get("changes", []) or []:
            if ch.get("field") == "comments":
                continue  # skip aici; comentariile sunt tratate separat
            val = ch.get("value") or {}
            for msg in val.get("messages", []) or []:
                if not isinstance(msg, dict):
                    continue
                from_field = msg.get("from") or val.get("from") or {}
                sender_id = from_field.get("id") if isinstance(from_field, dict) else from_field
                if not sender_id:
                    continue
                # normalize attachments
                attachments = None
                if isinstance(msg.get("attachments"), list):
                    attachments = msg["attachments"]
                elif isinstance(msg.get("attachments"), dict):
                    attachments = [msg["attachments"]]
                elif isinstance(msg.get("message"), dict):
                    inner = msg["message"]
                    if isinstance(inner.get("attachments"), list):
                        attachments = inner["attachments"]
                    elif isinstance(inner.get("attachments"), dict):
                        attachments = [inner["attachments"]]
                if attachments is not None:
                    msg = dict(msg)
                    msg["attachments"] = attachments

                if ("text" in msg) or ("attachments" in msg) or ("quick_reply" in msg):
                    yield sender_id, msg

def _is_ru_text(text: str) -> bool:
    return bool(CYRILLIC_RE.search(text or ""))

# Normalizare RO (fƒÉrƒÉ diacritice)
_DIAC_MAP = str.maketrans({"ƒÉ":"a","√¢":"a","√Æ":"i","»ô":"s","≈£":"t","»õ":"t",
                           "ƒÇ":"a","√Ç":"a","√é":"i","»ò":"s","≈¢":"t","»ö":"t"})
def _norm_ro(s: str) -> str:
    s = (s or "").lower().translate(_DIAC_MAP)
    s = re.sub(r"[^\w\s]", " ", s)   
    s = re.sub(r"\s+", " ", s).strip()
    return s


def _detect_offer_lang(text: str) -> str | None:
    """
    'RO' / 'RU' dacƒÉ mesajul indicƒÉ inten»õie de ofertƒÉ (pre»õ/cataloage/detalii).
    Reguli:
      1) Match direct pe expresii compuse (RO_PRICE_REGEX / RU_PRICE_REGEX)
      2) Scor lexiconic clasic: (PRICE ‚à™ DETAIL) + PRODUCT
      3) Fallback-uri prietenoase pentru mesaje scurte / √ÆntrebƒÉri simple:
         - doar PRODUCT (ex: "modele?", "catalog") -> ofertƒÉ
         - doar PRICE (ex: "c√¢t costƒÉ?", "—Ü–µ–Ω–∞?")  -> ofertƒÉ
    """
    if not text or not text.strip():
        return None

    has_cyr = bool(CYRILLIC_RE.search(text))
    low = (text or "").lower()
    low_clean = re.sub(r"[^\w\s]", " ", low)

    # RO normalize (fƒÉrƒÉ diacritice) + tokenizare
    ro_norm = _norm_ro(text)
    ro_toks = set(ro_norm.split())

    # RU tokenizare simplƒÉ
    ru_toks = set(low_clean.split())

    # 1) Expresii compuse ‚Äì ancore clare
    if has_cyr and RU_PRICE_REGEX.search(low):
        return "RU"
    if (not has_cyr) and RO_PRICE_REGEX.search(text):
        return "RO"

    # C√¢te cuvinte are mesajul (dupƒÉ normalizare)
    word_count = len((low_clean if has_cyr else ro_norm).split())

    # √éntrebƒÉri scurte de pre»õ (ex: "—Ü–µ–Ω–∞?", "c√¢t costƒÉ?")
    if not has_cyr and _SHORT_PRICE_RO.search(text) and ("?" in text or word_count <= 4):
        return "RO"
    if has_cyr and _SHORT_PRICE_RU.search(low) and ("?" in text or word_count <= 4):
        return "RU"

    # 2) Scor lexiconic clasic: (PRICE ‚à™ DETAIL) + PRODUCT
    ro_has_price_or_detail = bool(ro_toks & (RO_PRICE_TERMS | RO_DETAIL_TERMS))
    ro_has_product         = bool(ro_toks & RO_PRODUCT_TERMS)

    ru_has_price_or_detail = bool(ru_toks & (RU_PRICE_TERMS | RU_DETAIL_TERMS))
    ru_has_product         = bool(ru_toks & RU_PRODUCT_TERMS)

    if has_cyr:
        if ru_has_price_or_detail and ru_has_product:
            return "RU"
    else:
        if ro_has_price_or_detail and ro_has_product:
            return "RO"

    # 3) Fallback-uri prietenoase pentru mesaje scurte / cu semnul √ÆntrebƒÉrii

    # ‚Äî doar PRODUCT (modele/catalog) => ofertƒÉ
    if not has_cyr and (ro_has_product) and (word_count <= 5 or "?" in text):
        return "RO"
    if has_cyr and (ru_has_product) and (word_count <= 6 or "?" in text):
        return "RU"

    # ‚Äî doar PRICE/DETAIL, dacƒÉ e √Æntrebare scurtƒÉ (ex: "»ôi c√¢t costƒÉ?")
    if not has_cyr and ro_has_price_or_detail and (word_count <= 5 or "?" in text):
        return "RO"
    if has_cyr and ru_has_price_or_detail and (word_count <= 6 or "?" in text):
        return "RU"

    # Ultima plasƒÉ: ‚Äûdetalii?/–ø–æ–¥—Ä–æ–±–Ω–µ–µ?‚Äù
    if (ro_toks & RO_DETAIL_TERMS) and ("?" in text or ro_has_product):
        return "RO"
    if (ru_toks & RU_DETAIL_TERMS) and ("?" in text or ru_has_product):
        return "RU"

    return None



def _should_send_delivery(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RU' sau 'RO' dacƒÉ mesajul √ÆntreabƒÉ despre livrare
    »ôi nu am rƒÉspuns √ÆncƒÉ √Æn conversa»õia curentƒÉ. Altfel None.
    """
    if not text:
        return None
    if DELIVERY_REGEX.search(text):
        if DELIVERY_REPLIED.get(sender_id):
            return None
        DELIVERY_REPLIED[sender_id] = True
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _should_send_eta(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RU' sau 'RO' dacƒÉ mesajul √ÆntreabƒÉ despre termenul de executare
    »ôi nu am rƒÉspuns √ÆncƒÉ √Æn conversa»õia curentƒÉ. Altfel None.
    """
    if not text:
        return None
    if ETA_REGEX.search(text):
        if ETA_REPLIED.get(sender_id):
            return None
        ETA_REPLIED[sender_id] = True
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _should_send_followup(sender_id: str, text: str) -> str | None:
    """
    ReturneazƒÉ 'RO' sau 'RU' dacƒÉ mesajul e de tip 'mƒÉ g√¢ndesc/revin'.
    AsigurƒÉ o singurƒÉ trimitere per conversa»õie (anti-spam).
    """
    if not text:
        return None
    if FOLLOWUP_REGEX.search(text):
        if FOLLOWUP_REPLIED.get(sender_id):
            return None
        FOLLOWUP_REPLIED[sender_id] = True
        # limbƒÉ: dacƒÉ textul con»õine chirilice -> RU
        return "RU" if CYRILLIC_RE.search(text) else "RO"
    return None

def _send_dm_delayed(recipient_id: str, text: str, seconds: float | None = None) -> None:
    """
    Trimite DM cu √Ænt√¢rziere fƒÉrƒÉ sƒÉ blocheze webhook-ul.
    Nu atinge antispam-ul: tu chemi func»õia DOAR dupƒÉ ce ai trecut de guard-urile _should_*.
    """
    delay = seconds if seconds is not None else random.uniform(REPLY_DELAY_MIN_SEC, REPLY_DELAY_MAX_SEC)

    def _job():
        try:
            send_instagram_message(recipient_id, text[:900])
        except Exception as e:
            app.logger.exception("Delayed DM failed: %s", e)

    t = threading.Timer(delay, _job)
    t.daemon = True  # nu »õine procesul √Æn via»õƒÉ la shutdown
    t.start()

def _should_send_payment(sender_id: str, text: str) -> str | None:
    if not text:
        return None

    # declan»ôeazƒÉ pe plata generalƒÉ SAU pe √ÆntrebƒÉrile de avans
    if PAYMENT_REGEX.search(text) or ADVANCE_REGEX.search(text):
        if PAYMENT_REPLIED.get(sender_id):
            return None
        PAYMENT_REPLIED[sender_id] = True
        app.logger.info("[PAYMENT_MATCH] sender=%s text=%r", sender_id, text)
        return "RU" if CYRILLIC_RE.search(text) else "RO"

    return None

def _select_payment_message(lang: str, text: str) -> str:
    """
    Selector pentru tema 'platƒÉ':
      1) dacƒÉ e √Æntrebare despre SUMA avansului -> rƒÉspuns cu 200 lei (ADVANCE_TEXT_*)
      2) dacƒÉ e √Æntrebare despre METODA de achitare a avansului -> rƒÉspuns cu detaliile cardului (ADVANCE_METHOD_TEXT_*)
      3) altfel -> mesajul general despre platƒÉ (PAYMENT_TEXT_*)
    """
    low = (text or "").lower()
    has_cyr = bool(CYRILLIC_RE.search(low))

    # 1) SUMA avansului (prioritar)
    if ADVANCE_AMOUNT_REGEX.search(low):
        return ADVANCE_TEXT_RU if has_cyr or lang == "RU" else ADVANCE_TEXT_RO

    # 2) METODA de achitare a avansului (card/rechizite)
    if ADVANCE_METHOD_REGEX.search(low):
        return ADVANCE_METHOD_TEXT_RU if has_cyr or lang == "RU" else ADVANCE_METHOD_TEXT_RO

    # 3) General "cum se face achitarea?"
    return PAYMENT_TEXT_RU if has_cyr or lang == "RU" else PAYMENT_TEXT_RO



# ---------- Routes ----------
@app.get("/health")
def health():
    return {"ok": True}, 200

# Handshake (GET /webhook)
@app.get("/webhook")
def verify_webhook():
    mode = request.args.get("hub.mode")
    token = request.args.get("hub.verify_token")
    challenge = request.args.get("hub.challenge")
    if mode == "subscribe" and token == VERIFY_TOKEN:
        return challenge, 200
    return "Forbidden", 403

# Evenimente (POST /webhook): trateazƒÉ »ôi mesaje, »ôi comentarii
@app.post("/webhook")
def webhook():
    # (op»õional) verificare semnƒÉturƒÉ
    if not _verify_signature():
        app.logger.error("Invalid X-Hub-Signature-256")
        abort(403)

    data = request.get_json(force=True, silent=True) or {}
    app.logger.info("Incoming webhook: %s", json.dumps(data, ensure_ascii=False))

    # --- 1) Fluxul de COMENTARII (exact ca p√¢nƒÉ acum) ---
    for entry in data.get("entry", []):
        for change in entry.get("changes", []):
            if change.get("field") != "comments":
                continue  # ignorƒÉm ce nu e ‚Äûcomments‚Äù aici

            value = change.get("value", {}) or {}
            comment_id = value.get("id") or value.get("comment_id")
            text = value.get("text", "") or ""
            from_user = (value.get("from") or {}).get("id")

            app.logger.info(f"[DEBUG] Comment {comment_id} from user: {from_user}")

            # evitƒÉm self-replies
            if from_user and MY_IG_USER_ID and str(from_user) == str(MY_IG_USER_ID):
                continue
            if not comment_id:
                continue

            # DEDUP comentarii
            now = time.time()
            # curƒÉ»õare TTL
            for old_cid, ts in list(PROCESSED_COMMENTS.items()):
                if now - ts > COMMENT_TTL:
                    del PROCESSED_COMMENTS[old_cid]
            if comment_id in PROCESSED_COMMENTS:
                app.logger.info(f"[comments] Comment {comment_id} already processed, skipping")
                continue
            PROCESSED_COMMENTS[comment_id] = now
            app.logger.info(f"[comments] Processing new comment {comment_id}")

            # 1) rƒÉspuns public scurt (RO/RU)
            lang_ru = _is_ru_text(text)
            ack = ACK_PUBLIC_RU if lang_ru else ACK_PUBLIC_RO
            try:
                result = reply_public_to_comment(comment_id, ack)
                if isinstance(result, dict) and result.get("success") is False:
                    app.logger.info(f"[comments] Public reply not supported for {comment_id}, continue with private message")
            except Exception:
                app.logger.exception(f"[comments] Public reply failed for {comment_id}")

    # --- 2) Fluxul de MESAJE (DM) ‚Äî trigger ofertƒÉ + anti-spam ---
    for sender_id, msg in _iter_message_events(data):
        if msg.get("is_echo"):
            continue

        mid = msg.get("mid") or msg.get("id")
        if mid and _is_duplicate_mid(mid):
            continue

        text_in = (
            (msg.get("text"))
            or ((msg.get("message") or {}).get("text"))
            or ""
        ).strip()

        attachments = msg.get("attachments") if isinstance(msg.get("attachments"), list) else []
        app.logger.info("EVENT sender=%s text=%r attachments=%d", sender_id, text_in, len(attachments))

        # --- ETA (timp execu»õie) ‚Äî rƒÉspunde DOAR o datƒÉ per user ---
        lang_eta = _should_send_eta(sender_id, text_in)
        if lang_eta:
            try:
                msg_eta = ETA_TEXT_RU if lang_eta == "RU" else ETA_TEXT
                _send_dm_delayed(sender_id, msg_eta[:900])   
            except Exception as e:
                app.logger.exception("Failed to schedule ETA reply: %s", e)
            continue

        # --- LIVRARE (o singurƒÉ datƒÉ) ---
        lang_del = _should_send_delivery(sender_id, text_in)
        if lang_del:
            try:
                msg_del = DELIVERY_TEXT_RU if lang_del == "RU" else DELIVERY_TEXT
                _send_dm_delayed(sender_id, msg_del[:900])   
            except Exception as e:
                app.logger.exception("Failed to schedule delivery reply: %s", e)
            continue

        # --- FOLLOW-UP ‚Äî rƒÉspunde DOAR o datƒÉ ---
        lang_followup = _should_send_followup(sender_id, text_in)
        if lang_followup:
            reply = FOLLOWUP_TEXT_RU if lang_followup == "RU" else FOLLOWUP_TEXT_RO
            try:
                _send_dm_delayed(sender_id, reply[:900])     
            except Exception as e:
                app.logger.exception("Failed to schedule follow-up reply: %s", e)
            continue

        
        # --- PLATƒÇ / ACHITARE (o singurƒÉ datƒÉ) ---
        lang_pay = _should_send_payment(sender_id, text_in)
        if lang_pay:
            try:
                msg_pay = _select_payment_message(lang_pay, text_in)
                _send_dm_delayed(sender_id, msg_pay[:900])
            except Exception as e:
                app.logger.exception("Failed to schedule payment/advance reply: %s", e)
            continue


        # Trigger ofertƒÉ (RO/RU) o singurƒÉ datƒÉ √Æn fereastra de cooldown
        lang = _detect_offer_lang(text_in)
        if lang and _should_send_offer(sender_id):
            offer = OFFER_TEXT_RU if lang == "RU" else OFFER_TEXT_RO
            try:
                _send_dm_delayed(sender_id, offer[:900])     
            except Exception as e:
                app.logger.exception("Failed to schedule offer: %s", e)
            continue
        
        if "?" in text_in and len(text_in) <= 160:
            app.logger.info("[OFFER_INTENT_MISSING] %r", text_in)
        # AICI po»õi adƒÉuga alte fluxuri viitoare, dacƒÉ e cazul
        # (momentan webhook-ul rƒÉm√¢ne minimal pe DM)

    return jsonify({"ok": True}), 200

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=int(os.getenv("PORT", "8080")), debug=False)